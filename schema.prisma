// ------------------------------------------------------------
// Afterlife Service â€” Prisma Schema (MongoDB)
// ALL relations explicitly named; enums deduped
// Posts consolidated; Unified Feeds; Event comments enabled
// ------------------------------------------------------------
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mongodb"
  url      = env("DATABASE_URI")
}

// ---------------------- Enums -------------------------------

enum Visibility {
  PUBLIC
  UNLISTED
  PRIVATE
}

enum MemorialStatus {
  ACTIVE
  ARCHIVED
}

enum VerificationStatus {
  UNVERIFIED
  PENDING
  IN_REVIEW
  APPROVED
  REJECTED
}

enum ReviewDecision {
  PENDING
  APPROVED
  REJECTED
}

enum FundraisingStatus {
  ACTIVE
  PAUSED
  CLOSED
}

enum DonationStatus {
  SUCCEEDED
  REFUNDED
  FAILED
  PENDING
}

enum ContentFormat {
  IMAGE
  VIDEO
  AUDIO
  TEXT
  STICKER
  LIVESTREAM
}

enum PostStatus {
  DRAFT
  PUBLISHED
  MODERATION_HOLD
  REMOVED
}

enum LivestreamState {
  SCHEDULED
  LIVE
  ENDED
  CANCELED
}

enum RSVPStatus {
  GOING
  MAYBE
  NOT_GOING
  WAITLISTED
  CHECKED_IN
}

enum FollowTargetType {
  USER
  MEMORIAL
}

enum LikeTargetType {
  POST
}

enum CommentTargetType {
  POST
  EVENT
}

enum FeedType {
  MEMORIAL
  USER
  POST
  CATEGORY
  PROXIMITY
  CUSTOM
}

enum FeedStatus {
  ACTIVE
  EXPIRED
}

enum FeedEventType {
  IMPRESSION
  OPEN
  SCROLL
  CLICK
}

// ---------------------- Users & Sessions --------------------

model User {
  id          String    @id @default(auto()) @map("_id") @db.ObjectId
  email       String    @unique
  name        String?
  dateOfBirth DateTime? @default(now()) // for age-restricted content
  handle      String?   @unique @default(cuid())
  imageUrl    String?
  status      String    @default("ACTIVE")
  roles       String[]
  lastLogin   DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // relations
  sessions Session[] @relation(name: "UserSessions")
  follows  Follow[]  @relation(name: "UserFollows")
  likes    Like[]    @relation(name: "UserLikes")
  comments Comment[] @relation(name: "UserComments")
  posts    Post[]    @relation(name: "UserPosts")
}

model Session {
  id     String @id @default(auto()) @map("_id") @db.ObjectId
  userId String @db.ObjectId
  user   User   @relation(name: "UserSessions", fields: [userId], references: [id])

  token     String   @unique
  expiresAt DateTime
  userAgent String?
  ip        String?

  createdAt DateTime @default(now())

  @@index([userId, expiresAt])
}

// ---------------------- Memorials ---------------------------

model Memorial {
  id                       String              @id @default(auto()) @map("_id") @db.ObjectId
  slug                     String              @unique
  shortId                  String?             @unique
  ownerUserId              String
  displayName              String
  coverAssetUrl            String?
  coverAssetId             String?             @db.ObjectId
  salutation               String?
  yearOfBirth              Int?
  yearOfPassing            Int?
  theme                    String?             @default("default")
  location                 Location?
  bioSummary               String?
  tags                     String[]
  visibility               Visibility          @default(PUBLIC)
  status                   MemorialStatus      @default(ACTIVE)
  verificationStatus       VerificationStatus  @default(UNVERIFIED)
  iosAppUrl                String?
  androidAppUrl            String?
  shareUrl                 String?
  shortUrl                 String?
  obituaryId               String? // latest obituary draft ID
  obituaryServiceSessionId String? // questionnaire session ID
  createdAt                DateTime            @default(now())
  updatedAt                DateTime            @updatedAt
  archivedAt               DateTime?
  verificationCase         VerificationCase?   @relation(name: "MemorialVerification")
  fundraising              FundraisingProgram? @relation(name: "MemorialFundraising")
  posts                    Post[]              @relation(name: "PostMemorialPrimary")
  events                   Event[]             @relation(name: "MemorialEvents")

  @@index([displayName])
  @@index([verificationStatus, status])
  @@index([location])
}

type ObituaryCaption {
  draftId     String   @db.ObjectId
  captionText String   @db.String
  createdAt   DateTime @default(now())
}

model PublishedObituary {
  id          String           @id @default(auto()) @map("_id") @db.ObjectId
  memorialId  String           @db.ObjectId
  draftId     String           @db.ObjectId
  sessionId   String?          @db.ObjectId
  caption     ObituaryCaption?
  tone        String
  length      String
  content     String
  wordCount   Int?
  version     Int?
  publishedAt DateTime         @default(now())
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt

  @@index([memorialId])
  @@index([draftId])
}

type Location {
  googlePlaceId    String?
  formattedAddress String?
  lat              Float?
  lng              Float?
  city             String?
  state            String?
  country          String?
}

// ---------------------- Verification ------------------------

model VerificationCase {
  id         String   @id @default(auto()) @map("_id") @db.ObjectId
  memorialId String   @unique @db.ObjectId
  memorial   Memorial @relation(name: "MemorialVerification", fields: [memorialId], references: [id])

  submittedBy String
  inputs      VerificationInputs
  comparison  VerificationComparison?

  status      VerificationStatus @default(PENDING)
  reasonCodes String[]
  decidedAt   DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  documents      VerificationDoc[]   @relation(name: "VerificationDocuments")
  providerChecks ProviderCheck[]     @relation(name: "VerificationProviderChecks")
  manualReviews  ManualReview[]      @relation(name: "VerificationManualReviews")
  secrets        VerificationSecret? @relation(name: "VerificationSecrets")

  @@index([status])
}

model VerificationDoc {
  id             String           @id @default(auto()) @map("_id") @db.ObjectId
  verificationId String           @db.ObjectId
  verification   VerificationCase @relation(name: "VerificationDocuments", fields: [verificationId], references: [id])

  assetId        String
  kind           String // "death_certificate" | "supporting"
  uploadedAt     DateTime
  ocrText        String?
  matchScore     Float?
  verifiedFields String[]
}

model ProviderCheck {
  id             String           @id @default(auto()) @map("_id") @db.ObjectId
  verificationId String           @db.ObjectId
  verification   VerificationCase @relation(name: "VerificationProviderChecks", fields: [verificationId], references: [id])

  provider   String
  requestId  String?
  matchScore Float?
  result     String? // "match" | "no_match" | "inconclusive"
  raw        Json?

  createdAt DateTime @default(now())

  @@index([verificationId, provider])
}

model ManualReview {
  id             String           @id @default(auto()) @map("_id") @db.ObjectId
  verificationId String           @db.ObjectId
  verification   VerificationCase @relation(name: "VerificationManualReviews", fields: [verificationId], references: [id])

  reviewerUserId String
  notes          String?
  decision       ReviewDecision @default(PENDING)

  createdAt DateTime  @default(now())
  decidedAt DateTime?
}

model VerificationSecret {
  id             String           @id @default(auto()) @map("_id") @db.ObjectId
  verificationId String           @unique @db.ObjectId
  verification   VerificationCase @relation(name: "VerificationSecrets", fields: [verificationId], references: [id])

  // Encrypted full SSN (TEMPORARY)
  encFullSsn    String? // base64(ciphertext)
  encSsnIv      String? // base64(iv)
  encSsnAuthTag String? // base64(authTag)

  // Hashed identifiers (LONG-TERM)
  hashedSsn    String? // hash(fullSSN + salt), e.g. Argon2/Bcrypt
  hashedCertId String? // hash(deathCertificateId + salt)

  // Minimal metadata
  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt
  lastUsedAt DateTime? // last time we actually used encFullSsn for DMF
}

type VerificationInputs {
  fullName           String
  dateOfBirth        DateTime?
  dateOfPassing      DateTime?
  ssnLast4           String? // for display/confirmation only
  certificateNumber  String? // OPTIONAL, for human review; treat as sensitive
  state              String?
  county             String?
  deathCertificateId String? // OPTIONAL external ID (never stored in plaintext long-term)
}

type VerificationComparison {
  nameMatchScore         Float?
  dobMatchScore          Float?
  dopMatchScore          Float?
  certificateNumberMatch Float?
  overallScore           Float?
  notes                  String?
}

// ---------------------- Fundraising (mirror) ----------------

model FundraisingProgram {
  id         String   @id @default(auto()) @map("_id") @db.ObjectId
  memorialId String   @unique @db.ObjectId
  memorial   Memorial @relation(name: "MemorialFundraising", fields: [memorialId], references: [id])

  purpose                     String
  goalAmountCents             Int?
  currentAmountCents          Int               @default(0)
  currency                    String            @default("USD")
  status                      FundraisingStatus @default(ACTIVE)
  feePlanId                   String?
  connectAccountId            String?
  stripeCustomerId            String? // Customer for payout bank account setup
  beneficiaryType             String?
  beneficiaryName             String?
  beneficiaryExternalId       String?
  beneficiaryOnboardingStatus String?           @default("NOT_STARTED")
  totalPayoutsCents           Int               @default(0)
  lastPayoutAt                DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  donations DonationMirror[] @relation(name: "ProgramDonations")
  payouts   PayoutMirror[]   @relation(name: "ProgramPayouts")

  @@index([status])
  @@index([beneficiaryOnboardingStatus])
}

model DonationMirror {
  id            String             @id @default(auto()) @map("_id") @db.ObjectId
  fundraisingId String             @db.ObjectId
  fundraising   FundraisingProgram @relation(name: "ProgramDonations", fields: [fundraisingId], references: [id])

  billingPaymentId String         @unique
  amountCents      Int
  currency         String
  donorDisplay     String?
  message          String?
  status           DonationStatus
  madeAt           DateTime       @default(now())

  @@index([fundraisingId, status])
  @@index([madeAt])
}

model PayoutMirror {
  id            String             @id @default(auto()) @map("_id") @db.ObjectId
  fundraisingId String             @db.ObjectId
  fundraising   FundraisingProgram @relation(name: "ProgramPayouts", fields: [fundraisingId], references: [id])

  billingPayoutId    String    @unique
  amountCents        Int
  currency           String
  status             String
  initiatedAt        DateTime
  completedAt        DateTime?
  failureReason      String?
  destinationSummary String?
  metadata           Json?

  @@index([fundraisingId, status])
  @@index([initiatedAt])
}

// ---------------------- Posts (Consolidated) ----------------

type BaseMedia {
  mediaType     String // "image" | "video"
  assetId       String
  url           String
  aspectRatio   Float?
  durationMs    Int?
  parentAssetId String?
}

model Post {
  id           String             @id @default(auto()) @map("_id") @db.ObjectId
  authorUserId String?            @db.ObjectId
  author       User?              @relation(name: "UserPosts", fields: [authorUserId], references: [id])
  memorialId   String?            @db.ObjectId // primary memorial (TRIBUTE)
  memorial     Memorial?          @relation(name: "PostMemorialPrimary", fields: [memorialId], references: [id])
  caption      String?
  baseMedia    BaseMedia?
  thumbnail    BaseMedia?
  tags         String[]
  durationMs   Int?
  visibility   Visibility         @default(PUBLIC)
  status       PostStatus         @default(DRAFT)
  publishedAt  DateTime?
  metrics      PostMetrics?
  livestream   LivestreamSession? @relation(name: "PostLivestream")
  createdAt    DateTime           @default(now())
  updatedAt    DateTime           @updatedAt

  @@index([status, publishedAt])
  @@index([memorialId, publishedAt])
}

type PostMetrics {
  impressions Int @default(0)
  clicks      Int @default(0)
  watchTimeMs Int @default(0)
  likes       Int @default(0)
  flags       Int @default(0)
}

// ---------------------- Consolidated Follows / Likes / Comments ----

model Follow {
  id String @id @default(auto()) @map("_id") @db.ObjectId

  userId String @db.ObjectId
  user   User   @relation(name: "UserFollows", fields: [userId], references: [id])

  targetType    FollowTargetType // CREATOR | MEMORIAL
  targetId      String           @db.ObjectId
  notifications String?

  createdAt DateTime @default(now())

  @@unique([userId, targetType, targetId])
  @@index([targetType, targetId])
}

model Like {
  id String @id @default(auto()) @map("_id") @db.ObjectId

  userId String @db.ObjectId
  user   User   @relation(name: "UserLikes", fields: [userId], references: [id])

  targetType LikeTargetType // POST
  targetId   String         @db.ObjectId // Post.id

  createdAt DateTime @default(now())

  @@unique([userId, targetType, targetId])
  @@index([targetType, targetId])
}

model Comment {
  id String @id @default(auto()) @map("_id") @db.ObjectId

  authorUserId String @db.ObjectId
  author       User   @relation(name: "UserComments", fields: [authorUserId], references: [id])

  targetType CommentTargetType // POST | EVENT
  targetId   String            @db.ObjectId // Post.id or Event.id

  body      String
  status    String   @default("VISIBLE") // or MODERATED/REMOVED
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  parentCommentId String? @db.ObjectId

  @@index([targetType, targetId, createdAt])
  @@index([authorUserId, createdAt])
}

// ---------------------- Livestreams --------------------------

model LivestreamSession {
  id String @id @default(auto()) @map("_id") @db.ObjectId

  // FK lives here; back-rel on Post/Event
  postId String? @unique @db.ObjectId
  post   Post?   @relation(name: "PostLivestream", fields: [postId], references: [id])

  eventId String? @unique @db.ObjectId
  event   Event?  @relation(name: "EventLivestream", fields: [eventId], references: [id])

  state       LivestreamState  @default(SCHEDULED)
  ingest      LivestreamIngest
  playbackUrl String?

  startScheduledAt DateTime?
  startedAt        DateTime?
  endedAt          DateTime?

  viewerCount Int      @default(0)
  extras      Json?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([state])
}

type LivestreamIngest {
  url      String?
  key      String?
  protocol String? // "rtmp" | "webrtc"
}

// ---------------------- Events & RSVPs -----------------------

model Event {
  id String @id @default(auto()) @map("_id") @db.ObjectId

  memorialId String   @db.ObjectId
  memorial   Memorial @relation(name: "MemorialEvents", fields: [memorialId], references: [id])

  inMemoryOf  String?
  eventType   String
  title       String
  description String?

  startAt  DateTime
  endAt    DateTime
  timezone String

  location        EventLocation
  visibility      Visibility    @default(PUBLIC)
  capacity        Int?
  waitlistEnabled Boolean       @default(false)

  hostUserId String
  coHosts    String[]

  // livestream back-relation (FK on LivestreamSession)
  livestream LivestreamSession? @relation(name: "EventLivestream")

  status    String   @default("PUBLISHED")
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  rsvps RSVP[]       @relation(name: "EventRsvps")
  media EventMedia[] @relation(name: "EventMediaItems")

  // comments on events via consolidated Comment target (no hard FK)
  // (Optionally, you can maintain a denormalized commentsCount int here.)

  @@index([memorialId, startAt])
  @@index([visibility, startAt])
}

type EventLocation {
  kind             String // "physical" | "virtual" | "hybrid"
  googlePlaceId    String?
  formattedAddress String?
  lat              Float?
  lng              Float?
  joinUrl          String?
}

model RSVP {
  id String @id @default(auto()) @map("_id") @db.ObjectId

  eventId String @db.ObjectId
  event   Event  @relation(name: "EventRsvps", fields: [eventId], references: [id])

  userId      String?
  email       String?
  status      RSVPStatus @default(GOING)
  guestsCount Int        @default(1)
  notes       String?

  checkin   Checkin?
  createdAt DateTime @default(now())

  @@index([eventId, status])
  @@index([email])
}

type Checkin {
  at DateTime?
  by String? // staff/co-host userId
}

model EventMedia {
  id String @id @default(auto()) @map("_id") @db.ObjectId

  eventId String @db.ObjectId
  event   Event  @relation(name: "EventMediaItems", fields: [eventId], references: [id])

  assetId   String // Content Service asset id (program, gallery, recording)
  kind      String // "program" | "gallery" | "recording"
  createdAt DateTime @default(now())

  @@index([eventId, kind])
}

type Proximity {
  lat     Float
  lng     Float
  radiusM Int
}

// ---------------------- Audit & Logs -------------------------

model AuditLog {
  id          String   @id @default(auto()) @map("_id") @db.ObjectId
  subjectType String // "Memorial" | "VerificationCase" | "Post" | "Event" | ...
  subjectId   String
  actorUserId String?
  action      String
  payload     Json?
  createdAt   DateTime @default(now())

  @@index([subjectType, subjectId, createdAt])
}
